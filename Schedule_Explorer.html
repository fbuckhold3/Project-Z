<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Z — Schedule Explorer</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            color: #333;
        }

        /* HEADER */
        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 20px 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .header-title {
            font-size: 24px;
            font-weight: 600;
        }

        .header-subtitle {
            font-size: 13px;
            opacity: 0.9;
        }

        .header-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .level-toggle {
            display: flex;
            gap: 5px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            padding: 4px;
        }

        .level-btn {
            padding: 8px 16px;
            border: none;
            background: transparent;
            color: white;
            cursor: pointer;
            border-radius: 3px;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .level-btn.active {
            background: rgba(255,255,255,0.3);
        }

        .level-btn:hover {
            background: rgba(255,255,255,0.15);
        }

        .kpi-chips {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .kpi-chip {
            background: rgba(255,255,255,0.15);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }

        .kpi-label {
            opacity: 0.8;
            margin-right: 4px;
        }

        .kpi-value {
            font-weight: 700;
        }

        /* LAYOUT */
        .container {
            display: flex;
            height: calc(100vh - 80px);
            gap: 0;
        }

        /* SIDEBAR */
        .sidebar {
            width: 320px;
            background: white;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            padding: 20px;
            box-shadow: 1px 0 3px rgba(0,0,0,0.05);
        }

        .section {
            margin-bottom: 24px;
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-weight: 600;
            color: #1e3c72;
            user-select: none;
            padding: 8px 0;
            font-size: 14px;
        }

        .section-header:hover {
            color: #2a5298;
        }

        .section-toggle {
            display: inline-block;
            width: 16px;
            text-align: center;
            font-size: 11px;
        }

        .section-content {
            padding-top: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .section.collapsed .section-content {
            display: none;
        }

        .param-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .param-label {
            font-size: 12px;
            font-weight: 500;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .param-input {
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            font-family: inherit;
            transition: border-color 0.2s;
        }

        .param-input:focus {
            outline: none;
            border-color: #2a5298;
            box-shadow: 0 0 0 3px rgba(42, 82, 152, 0.1);
        }

        .param-input-group {
            display: flex;
            gap: 8px;
        }

        .param-input-group input {
            flex: 1;
        }

        .button {
            padding: 12px 16px;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            user-select: none;
        }

        .button-primary {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            width: 100%;
            margin-top: 12px;
        }

        .button-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(42, 82, 152, 0.3);
        }

        .button-primary:active {
            transform: translateY(0);
        }

        .button-secondary {
            background: #f0f0f0;
            color: #333;
            width: 100%;
            border: 1px solid #ddd;
            margin-top: 8px;
        }

        .button-secondary:hover {
            background: #e8e8e8;
        }

        /* MAIN PANEL */
        .main-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
        }

        .tabs {
            display: flex;
            gap: 0;
            border-bottom: 1px solid #ddd;
            background: #fafafa;
            padding: 0 20px;
            overflow-x: auto;
        }

        .tab {
            padding: 14px 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .tab:hover {
            color: #1e3c72;
        }

        .tab.active {
            color: #1e3c72;
            border-bottom-color: #2a5298;
        }

        .tab-content {
            flex: 1;
            overflow: auto;
            padding: 20px;
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* SCHEDULE GRID */
        .schedule-table {
            border-collapse: collapse;
            font-size: 12px;
            width: 100%;
            background: white;
        }

        .schedule-table th, .schedule-table td {
            border: 1px solid #e0e0e0;
            padding: 4px 6px;
            text-align: center;
            height: 28px;
        }

        .schedule-table th {
            background: #f5f5f5;
            font-weight: 600;
            color: #333;
            position: sticky;
            top: 0;
            z-index: 2;
        }

        .schedule-table tr:nth-child(even) {
            background: #f9f9f9;
        }

        .schedule-table tr.separator {
            background: #e8e8e8 !important;
            height: 24px;
        }

        .schedule-table tr.separator td {
            border: none;
            padding: 2px 6px;
            font-size: 11px;
            font-weight: 600;
            color: #666;
        }

        .schedule-table .resident-name {
            text-align: left;
            font-weight: 500;
            background: #f0f0f0;
            position: sticky;
            left: 0;
            z-index: 1;
            min-width: 80px;
        }

        .schedule-cell {
            cursor: pointer;
            position: relative;
            overflow: hidden;
            font-weight: 500;
            color: #333;
        }

        .schedule-cell:hover {
            filter: brightness(0.95);
        }

        .color-legend {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            margin-bottom: 16px;
            padding: 12px;
            background: #f9f9f9;
            border-radius: 4px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-swatch {
            width: 20px;
            height: 20px;
            border-radius: 2px;
            border: 1px solid #ccc;
        }

        /* TABS CONTENT */
        .coverage-table, .balance-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            background: white;
        }

        .coverage-table th, .balance-table th {
            background: #f5f5f5;
            padding: 10px;
            text-align: left;
            font-weight: 600;
            border: 1px solid #e0e0e0;
        }

        .coverage-table td, .balance-table td {
            padding: 8px 10px;
            border: 1px solid #e0e0e0;
        }

        .coverage-table tr:nth-child(even),
        .balance-table tr:nth-child(even) {
            background: #f9f9f9;
        }

        .plot-container {
            width: 100%;
            height: 500px;
            margin-bottom: 20px;
        }

        .kpi-comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .kpi-card {
            background: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 16px;
        }

        .kpi-card-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 6px;
            text-transform: uppercase;
            font-weight: 600;
        }

        .kpi-card-values {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 12px;
        }

        .kpi-baseline, .kpi-current {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .kpi-baseline-label, .kpi-current-label {
            font-size: 10px;
            color: #999;
            margin-bottom: 4px;
        }

        .kpi-baseline-value, .kpi-current-value {
            font-size: 18px;
            font-weight: 700;
        }

        .kpi-delta {
            font-size: 18px;
            font-weight: 700;
            margin-left: 8px;
        }

        .kpi-delta.improved {
            color: #4caf50;
        }

        .kpi-delta.degraded {
            color: #f44336;
        }

        .kpi-delta.same {
            color: #999;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f5f5f5;
        }

        ::-webkit-scrollbar-thumb {
            background: #bbb;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #999;
        }

        /* LOADING */
        .loading {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
            text-align: center;
            z-index: 1000;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid #f0f0f0;
            border-top-color: #2a5298;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 12px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* RESPONSIVE */
        @media (max-width: 1200px) {
            .sidebar {
                width: 280px;
            }
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                max-height: 300px;
                border-right: none;
                border-bottom: 1px solid #ddd;
            }
        }
    </style>
</head>
<body>
    <!-- HEADER -->
    <div class="header">
        <div class="header-left">
            <div class="header-title">Project Z — Schedule Explorer</div>
            <div class="header-subtitle">ABC Model • Interactive Design Tool</div>
        </div>
        <div class="header-controls">
            <div class="level-toggle">
                <button class="level-btn active" data-level="senior">Senior (PGY-2/3)</button>
                <button class="level-btn" data-level="intern">Intern (PGY-1)</button>
            </div>
            <div class="kpi-chips">
                <div class="kpi-chip">
                    <span class="kpi-label">Residents:</span>
                    <span class="kpi-value" id="kpi-residents">55</span>
                </div>
                <div class="kpi-chip">
                    <span class="kpi-label">Fully Staffed:</span>
                    <span class="kpi-value" id="kpi-staffed">0</span>
                </div>
                <div class="kpi-chip">
                    <span class="kpi-label">Max Consec:</span>
                    <span class="kpi-value" id="kpi-maxconsec">0</span>
                </div>
                <div class="kpi-chip">
                    <span class="kpi-label">Violations:</span>
                    <span class="kpi-value" id="kpi-violations">0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- MAIN LAYOUT -->
    <div class="container">
        <!-- SIDEBAR -->
        <div class="sidebar">
            <!-- ROSTER -->
            <div class="section">
                <div class="section-header" onclick="toggleSection(this)">
                    <span class="section-toggle">▼</span>
                    <span>Roster</span>
                </div>
                <div class="section-content">
                    <div id="roster-container"></div>
                </div>
            </div>

            <!-- ROTATORS (INTERN ONLY) -->
            <div class="section" id="rotators-section" style="display: none;">
                <div class="section-header" onclick="toggleSection(this)">
                    <span class="section-toggle">▼</span>
                    <span>Rotators</span>
                </div>
                <div class="section-content">
                    <div id="rotators-container"></div>
                </div>
            </div>

            <!-- TARGETS -->
            <div class="section">
                <div class="section-header" onclick="toggleSection(this)">
                    <span class="section-toggle">▼</span>
                    <span>Weekly Targets</span>
                </div>
                <div class="section-content">
                    <div id="targets-container"></div>
                </div>
            </div>

            <!-- RULES -->
            <div class="section">
                <div class="section-header" onclick="toggleSection(this)">
                    <span class="section-toggle">▼</span>
                    <span>Scheduling Rules</span>
                </div>
                <div class="section-content">
                    <div class="param-group">
                        <label class="param-label">Ward Contiguity</label>
                        <input type="number" id="ward-contiguity" class="param-input" min="1" max="4" value="3">
                    </div>
                    <div class="param-group">
                        <label class="param-label">NF Contiguity</label>
                        <input type="number" id="nf-contiguity" class="param-input" min="1" max="3" value="2">
                    </div>
                    <div class="param-group">
                        <label class="param-label">Max Consecutive IP</label>
                        <input type="number" id="max-consec-ip" class="param-input" min="2" max="5" value="3">
                    </div>
                    <div class="param-group">
                        <label class="param-label">Jeopardy Cap/Year</label>
                        <input type="number" id="jeopardy-cap" class="param-input" min="1" max="10" value="4">
                    </div>
                    <div class="param-group">
                        <label class="param-label">Clinic Frequency</label>
                        <input type="number" id="clinic-frequency" class="param-input" min="4" max="8" value="6">
                    </div>
                </div>
            </div>

            <!-- SEED -->
            <div class="section">
                <div class="section-header" onclick="toggleSection(this)">
                    <span class="section-toggle">▼</span>
                    <span>Advanced</span>
                </div>
                <div class="section-content">
                    <div class="param-group">
                        <label class="param-label">Random Seed</label>
                        <input type="number" id="seed" class="param-input" value="42">
                    </div>
                    <button class="button button-secondary" onclick="findBestSeed()">Search Seeds 0-99</button>
                </div>
            </div>

            <!-- ACTIONS -->
            <button class="button button-primary" onclick="generateSchedule()">Generate Schedule</button>
            <button class="button button-secondary" onclick="saveBaseline()">Save as Baseline</button>
            <button class="button button-secondary" onclick="resetDefaults()">Reset Defaults</button>
        </div>

        <!-- MAIN PANEL -->
        <div class="main-panel">
            <div class="tabs">
                <button class="tab active" onclick="switchTab(0)">Schedule Grid</button>
                <button class="tab" onclick="switchTab(1)">Coverage & Staffing</button>
                <button class="tab" onclick="switchTab(2)">Balance & Fairness</button>
                <button class="tab" id="compare-tab" onclick="switchTab(3)" style="display: none;">Compare</button>
            </div>

            <!-- TAB 1: SCHEDULE GRID -->
            <div class="tab-content active">
                <div class="color-legend" id="color-legend"></div>
                <div style="overflow-x: auto; overflow-y: auto; flex: 1;">
                    <table class="schedule-table" id="schedule-grid"></table>
                </div>
            </div>

            <!-- TAB 2: COVERAGE & STAFFING -->
            <div class="tab-content">
                <h3>Coverage Heatmap</h3>
                <div class="plot-container" id="coverage-heatmap"></div>
                <h3>Weekly Coverage Summary</h3>
                <div style="overflow-x: auto;">
                    <table class="coverage-table" id="coverage-table"></table>
                </div>
            </div>

            <!-- TAB 3: BALANCE & FAIRNESS -->
            <div class="tab-content">
                <h3>IP Weeks Distribution</h3>
                <div class="plot-container" id="balance-histogram"></div>
                <h3>Per-Rotation Balance</h3>
                <div class="plot-container" id="rotation-boxplot"></div>
                <h3>Outliers (>1.5 SD from mean)</h3>
                <div style="overflow-x: auto;">
                    <table class="balance-table" id="outliers-table"></table>
                </div>
            </div>

            <!-- TAB 4: COMPARE -->
            <div class="tab-content">
                <div id="compare-content"></div>
            </div>
        </div>
    </div>

    <!-- LOADING SPINNER -->
    <div class="loading" id="loading">
        <div class="spinner"></div>
        <div>Generating schedule...</div>
    </div>

    <script>
        // ============================================================================
        // DATA & STATE
        // ============================================================================

        const COLORS = {
            SLUH: '#B3D9FF',
            VA: '#FFCC99',
            NF: '#D9B3FF',
            MICU: '#FFB3B3',
            Cards: '#FFFFB3',
            OP: '#B3FFB3',
            Clinic: '#FFFFFF',
            Jeopardy: '#FFE0B2',
            ID: '#C8E6C9',
            Bronze: '#FFE0B2',
            Diamond: '#E1BEE7',
            Gold: '#FFF9C4',
            'ICU*': '#FFD9D9'
        };

        const ABBREV = {
            SLUH: 'SLUH',
            VA: 'VA',
            NF: 'NF',
            MICU: 'MICU',
            Cards: 'CRD',
            OP: 'OP',
            Clinic: 'CL',
            Jeopardy: 'JEO',
            ID: 'ID',
            Bronze: 'BRZ',
            Diamond: 'DIA',
            Gold: 'GLD',
            'ICU*': 'ICU*'
        };

        const SENIOR_DEFAULTS = {
            N_PGY3: 27,
            N_PGY2: 28,
            TW: 48,
            CYCLE: 6,
            SLUH: 6,
            VA: 5,
            ID: 1,
            NF: 5,
            MICU: 4,
            Bronze: 2,
            Cards: 2,
            Diamond: 1,
            Gold: 1,
            ward_contiguity: 3,
            nf_contiguity: 2,
            max_consec_ip: 3,
            jeopardy_cap: 4,
            clinic_frequency: 6,
            seed: 42
        };

        const INTERN_DEFAULTS = {
            N_CAT: 26,
            N_PRELIM: 5,
            TW: 48,
            Neuro: 6,
            Anes: 10,
            Psych: 8,
            EM: 8,
            SLUH: 4,
            VA: 5,
            NF: 4,
            MICU: 2,
            Cards: 1,
            ward_contiguity: 3,
            nf_contiguity: 2,
            max_consec_ip: 3,
            jeopardy_cap: 3,
            clinic_frequency: 6,
            seed: 6
        };

        let currentLevel = 'senior';
        let schedule = null;
        let coverage = null;
        let rotatorSchedule = null;
        let rotatorCoverage = null;
        let baseline = null;
        let baselineRotatorSchedule = null;
        let baselineCoverage = null;
        let baselineRotatorCoverage = null;

        // ============================================================================
        // MULBERRY32 PRNG
        // ============================================================================

        function mulberry32(a) {
            return function() {
                a |= 0;
                a = a + 0x6D2B79F5 | 0;
                var t = Math.imul(a ^ a >>> 15, 1 | a);
                t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        // ============================================================================
        // SENIOR SCHEDULER (CORRECTED WITH COVERAGE-TRACKING WHILE LOOPS)
        // ============================================================================

        function scheduleSenior(params) {
            const {
                N_PGY3, N_PGY2, TW, CYCLE,
                SLUH, VA, ID, NF, MICU, Bronze, Cards, Diamond, Gold,
                ward_contiguity, nf_contiguity, max_consec_ip, jeopardy_cap, clinic_frequency, seed
            } = params;

            const N = N_PGY3 + N_PGY2;
            const rng = mulberry32(seed);

            const TARGETS = { SLUH, VA, ID, NF, MICU, Bronze, Cards, Diamond, Gold };
            const IP_ROTS = new Set(['SLUH', 'VA', 'ID', 'NF', 'MICU', 'Bronze', 'Cards', 'Diamond', 'Gold']);
            const STAG_ROTS = new Set(['MICU', 'Bronze', 'Cards']);
            const WARD_ROTS = ['SLUH', 'VA', 'ID'];

            const IDEAL = {};
            Object.keys(TARGETS).forEach(rot => {
                IDEAL[rot] = (TARGETS[rot] * TW) / N;
            });

            // Initialize residents
            const residents = [];
            for (let i = 0; i < N_PGY3; i++) {
                residents.push({ id: i, level: 'PGY3', name: `PGY3-${i+1}` });
            }
            for (let i = 0; i < N_PGY2; i++) {
                residents.push({ id: N_PGY3 + i, level: 'PGY2', name: `PGY2-${i+1}` });
            }

            // Initialize schedule and coverage
            const schedule = {};
            const coverage = {};
            residents.forEach(r => {
                schedule[r.id] = {};
                for (let w = 0; w < TW; w++) {
                    schedule[r.id][w] = null;
                }
            });

            Object.keys(TARGETS).forEach(rot => {
                coverage[rot] = {};
                for (let w = 0; w < TW; w++) {
                    coverage[rot][w] = 0;
                }
            });

            // Clinic: position-based assignment
            const positions = [];
            for (let p = 1; p <= 6; p++) {
                const perPos = Math.floor(N / 6) + (p <= N % 6 ? 1 : 0);
                for (let i = 0; i < perPos; i++) {
                    positions.push(p);
                }
            }
            // Shuffle positions
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }

            for (let rid = 0; rid < N; rid++) {
                const pos = positions[rid];
                for (let c = 0; c < Math.floor(TW / clinic_frequency); c++) {
                    const w = c * clinic_frequency + (pos - 1);
                    if (w < TW) {
                        schedule[rid][w] = 'Clinic';
                    }
                }
            }

            // Track assigned weeks per rotation
            const resWeeks = {};
            residents.forEach(r => {
                resWeeks[r.id] = {};
                Object.keys(TARGETS).forEach(rot => {
                    resWeeks[r.id][rot] = 0;
                });
            });

            // Helper: wouldExceed
            function wouldExceed(rid, weeks, maxConsec) {
                const tempSched = { ...schedule[rid] };
                weeks.forEach(w => {
                    tempSched[w] = 'TEMP';
                });
                let maxRun = 0, currentRun = 0;
                for (let w = 0; w < TW; w++) {
                    const val = tempSched[w];
                    if (val !== null && val !== 'Clinic' && (IP_ROTS.has(val) || val === 'TEMP')) {
                        currentRun++;
                        maxRun = Math.max(maxRun, currentRun);
                    } else {
                        currentRun = 0;
                    }
                }
                return maxRun > maxConsec;
            }

            // Helper: balanceScore
            function balanceScore(rid, rot, extraWeeks) {
                const current = resWeeks[rid][rot];
                const ideal = IDEAL[rot] || 0.5;
                const rotExcess = (current + extraWeeks) / Math.max(ideal, 0.5);
                const totalIp = Object.keys(TARGETS).reduce((sum, r) => sum + resWeeks[rid][r], 0);
                const idealMeanIP = (Object.values(TARGETS).reduce((a, b) => a + b) * TW / N) / 2.0;
                return rotExcess + 0.3 * (totalIp / Math.max(idealMeanIP, 0.5));
            }

            // PASS 1: Ward rotations (3-week blocks) - SLUH, VA, ID
            WARD_ROTS.forEach(rot => {
                const target = TARGETS[rot];

                for (let w = 0; w <= TW - ward_contiguity; w++) {
                    while (coverage[rot][w] < target) {
                        const candidates = [];

                        residents.forEach(r => {
                            let allFree = true;
                            for (let i = 0; i < ward_contiguity; i++) {
                                if (schedule[r.id][w + i] !== null) {
                                    allFree = false;
                                    break;
                                }
                            }

                            if (allFree && !wouldExceed(r.id, Array.from({length: ward_contiguity}, (_, i) => w + i), max_consec_ip)) {
                                const score = balanceScore(r.id, rot, ward_contiguity);
                                candidates.push({ rid: r.id, score, rand: rng() });
                            }
                        });

                        if (candidates.length === 0) break;

                        candidates.sort((a, b) => a.score - b.score || a.rand - b.rand);
                        const rid = candidates[0].rid;

                        for (let i = 0; i < ward_contiguity; i++) {
                            schedule[rid][w + i] = rot;
                            coverage[rot][w + i]++;
                        }
                        resWeeks[rid][rot] += ward_contiguity;
                    }
                }
            });

            // PASS 2: NF (2-week blocks)
            for (let w = 0; w <= TW - nf_contiguity; w++) {
                while (coverage['NF'][w] < NF) {
                    const candidates = [];

                    residents.forEach(r => {
                        let allFree = true;
                        for (let i = 0; i < nf_contiguity; i++) {
                            if (schedule[r.id][w + i] !== null) {
                                allFree = false;
                                break;
                            }
                        }

                        if (allFree && !wouldExceed(r.id, Array.from({length: nf_contiguity}, (_, i) => w + i), max_consec_ip)) {
                            const score = balanceScore(r.id, 'NF', nf_contiguity);
                            candidates.push({ rid: r.id, score, rand: rng() });
                        }
                    });

                    if (candidates.length === 0) break;

                    candidates.sort((a, b) => a.score - b.score || a.rand - b.rand);
                    const rid = candidates[0].rid;

                    for (let i = 0; i < nf_contiguity; i++) {
                        schedule[rid][w + i] = 'NF';
                        coverage['NF'][w + i]++;
                    }
                    resWeeks[rid]['NF'] += nf_contiguity;
                }
            }

            // PASS 3: Staggered (MICU, Bronze, Cards)
            Array.from(STAG_ROTS).forEach(rot => {
                const target = TARGETS[rot];

                for (let w = 0; w < TW; w++) {
                    while (coverage[rot][w] < target) {
                        const candidates = [];

                        residents.forEach(r => {
                            let valid = schedule[r.id][w] === null;

                            if (valid && w > 0 && STAG_ROTS.has(schedule[r.id][w - 1])) {
                                valid = false;
                            }
                            if (valid && w < TW - 1 && STAG_ROTS.has(schedule[r.id][w + 1])) {
                                valid = false;
                            }

                            if (valid && !wouldExceed(r.id, [w], max_consec_ip)) {
                                const score = balanceScore(r.id, rot, 1);
                                candidates.push({ rid: r.id, score, rand: rng() });
                            }
                        });

                        if (candidates.length === 0) break;

                        candidates.sort((a, b) => a.score - b.score || a.rand - b.rand);
                        const rid = candidates[0].rid;

                        schedule[rid][w] = rot;
                        coverage[rot][w]++;
                        resWeeks[rid][rot] += 1;
                    }
                }
            });

            // PASS 4: Diamond and Gold
            ['Diamond', 'Gold'].forEach(rot => {
                const target = TARGETS[rot];

                for (let w = 0; w < TW; w++) {
                    while (coverage[rot][w] < target) {
                        const candidates = [];

                        residents.forEach(r => {
                            if (schedule[r.id][w] === null && !wouldExceed(r.id, [w], max_consec_ip)) {
                                const score = balanceScore(r.id, rot, 1);
                                candidates.push({ rid: r.id, score, rand: rng() });
                            }
                        });

                        if (candidates.length === 0) break;

                        candidates.sort((a, b) => a.score - b.score || a.rand - b.rand);
                        const rid = candidates[0].rid;

                        schedule[rid][w] = rot;
                        coverage[rot][w]++;
                        resWeeks[rid][rot] += 1;
                    }
                }
            });

            // PASS 5: Fill with OP
            residents.forEach(r => {
                for (let w = 0; w < TW; w++) {
                    if (schedule[r.id][w] === null) {
                        schedule[r.id][w] = 'OP';
                    }
                }
            });

            // PASS 6: Jeopardy
            const jeopardyCount = {};
            residents.forEach(r => {
                jeopardyCount[r.id] = 0;
            });

            const jeopPerWeek = {};
            for (let w = 0; w < TW; w++) jeopPerWeek[w] = 0;

            const opPool = [];
            residents.forEach(r => {
                for (let w = 0; w < TW; w++) {
                    if (schedule[r.id][w] === 'OP') {
                        opPool.push({ rid: r.id, w });
                    }
                }
            });

            for (let i = opPool.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [opPool[i], opPool[j]] = [opPool[j], opPool[i]];
            }

            opPool.forEach(item => {
                if (jeopardyCount[item.rid] < jeopardy_cap && (jeopPerWeek[item.w] || 0) < 1) {
                    schedule[item.rid][item.w] = 'Jeopardy';
                    jeopardyCount[item.rid]++;
                    jeopPerWeek[item.w]++;
                }
            });

            return { schedule, residents, coverage };
        }

        // ============================================================================
        // INTERN SCHEDULER (CORRECTED WITH COVERAGE-TRACKING WHILE LOOPS)
        // ============================================================================

        function scheduleIntern(params) {
            const {
                N_CAT, N_PRELIM, TW,
                Neuro, Anes, Psych, EM,
                SLUH, VA, NF, MICU, Cards,
                ward_contiguity, nf_contiguity, max_consec_ip, jeopardy_cap, clinic_frequency, seed
            } = params;

            const N = N_CAT + N_PRELIM;
            const rng = mulberry32(seed);

            const TARGETS = { SLUH, VA, NF, MICU, Cards };
            const IP_ROTS = new Set(['SLUH', 'VA', 'NF', 'MICU', 'Cards']);
            const STAG_ROTS = new Set(['MICU', 'Cards']);

            // Initialize rotators
            const rotatorSchedule = {};

            // Neuro: 6 residents, 24 slots
            const neuroSlots = [];
            for (let m = 0; m < 12; m++) {
                neuroSlots.push({ month: m, loc: 'SLUH' });
                neuroSlots.push({ month: m, loc: 'VA' });
            }
            for (let i = neuroSlots.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [neuroSlots[i], neuroSlots[j]] = [neuroSlots[j], neuroSlots[i]];
            }
            for (let i = 0; i < Neuro; i++) {
                rotatorSchedule[`Neuro-${i}`] = {};
                for (let w = 0; w < TW; w++) {
                    rotatorSchedule[`Neuro-${i}`][w] = null;
                }
                for (let s = 0; s < 4; s++) {
                    const slot = neuroSlots[i * 4 + s];
                    const wStart = slot.month * 4;
                    for (let w = 0; w < 4; w++) {
                        if (wStart + w < TW) {
                            rotatorSchedule[`Neuro-${i}`][wStart + w] = slot.loc;
                        }
                    }
                }
            }

            // Anes: 10 residents, 1 month SLUH
            const anesMonths = [];
            for (let m = 0; m < 12; m++) anesMonths.push(m);
            for (let i = anesMonths.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [anesMonths[i], anesMonths[j]] = [anesMonths[j], anesMonths[i]];
            }
            for (let i = 0; i < Anes; i++) {
                rotatorSchedule[`Anes-${i}`] = {};
                for (let w = 0; w < TW; w++) {
                    rotatorSchedule[`Anes-${i}`][w] = null;
                }
                const m = anesMonths[i % 12];
                const wStart = m * 4;
                for (let w = 0; w < 4; w++) {
                    if (wStart + w < TW) {
                        rotatorSchedule[`Anes-${i}`][wStart + w] = 'SLUH';
                    }
                }
            }

            // Psych: 8 residents, 1 month VA
            const psychMonths = [];
            for (let m = 0; m < 12; m++) psychMonths.push(m);
            for (let i = psychMonths.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [psychMonths[i], psychMonths[j]] = [psychMonths[j], psychMonths[i]];
            }
            for (let i = 0; i < Psych; i++) {
                rotatorSchedule[`Psych-${i}`] = {};
                for (let w = 0; w < TW; w++) {
                    rotatorSchedule[`Psych-${i}`][w] = null;
                }
                const m = psychMonths[i % 12];
                const wStart = m * 4;
                for (let w = 0; w < 4; w++) {
                    if (wStart + w < TW) {
                        rotatorSchedule[`Psych-${i}`][wStart + w] = 'VA';
                    }
                }
            }

            // EM: 8 residents, 1 month ICU*
            const emMonths = [];
            for (let m = 0; m < 12; m++) emMonths.push(m);
            for (let i = emMonths.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [emMonths[i], emMonths[j]] = [emMonths[j], emMonths[i]];
            }
            for (let i = 0; i < EM; i++) {
                rotatorSchedule[`EM-${i}`] = {};
                for (let w = 0; w < TW; w++) {
                    rotatorSchedule[`EM-${i}`][w] = null;
                }
                const m = emMonths[i % 12];
                const wStart = m * 4;
                for (let w = 0; w < 4; w++) {
                    if (wStart + w < TW) {
                        rotatorSchedule[`EM-${i}`][wStart + w] = 'ICU*';
                    }
                }
            }

            // Count rotator coverage
            const rotatorSluhPerWeek = {}, rotatorVaPerWeek = {};
            for (let w = 0; w < TW; w++) {
                rotatorSluhPerWeek[w] = 0;
                rotatorVaPerWeek[w] = 0;
            }

            Object.keys(rotatorSchedule).forEach(rid => {
                for (let w = 0; w < TW; w++) {
                    const rot = rotatorSchedule[rid][w];
                    if (rot === 'SLUH') rotatorSluhPerWeek[w]++;
                    else if (rot === 'VA') rotatorVaPerWeek[w]++;
                }
            });

            // Dynamic intern targets
            const internSluhTarget = {}, internVaTarget = {};
            for (let w = 0; w < TW; w++) {
                internSluhTarget[w] = Math.max(0, SLUH - rotatorSluhPerWeek[w]);
                internVaTarget[w] = Math.max(0, VA - rotatorVaPerWeek[w]);
            }

            // Initialize interns
            const residents = [];
            for (let i = 0; i < N_CAT; i++) {
                residents.push({ id: i, level: 'CAT', name: `CAT-${i+1}` });
            }
            for (let i = 0; i < N_PRELIM; i++) {
                residents.push({ id: N_CAT + i, level: 'PRELIM', name: `PRELIM-${i+1}` });
            }

            const schedule = {};
            const coverage = {};
            residents.forEach(r => {
                schedule[r.id] = {};
                for (let w = 0; w < TW; w++) {
                    schedule[r.id][w] = null;
                }
            });

            Object.keys(TARGETS).forEach(rot => {
                coverage[rot] = {};
                for (let w = 0; w < TW; w++) {
                    coverage[rot][w] = 0;
                }
            });

            // Clinic
            const positions = [];
            for (let p = 1; p <= 6; p++) {
                const perPos = Math.floor(N / 6) + (p <= N % 6 ? 1 : 0);
                for (let i = 0; i < perPos; i++) {
                    positions.push(p);
                }
            }
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }

            for (let rid = 0; rid < N; rid++) {
                const pos = positions[rid];
                for (let c = 0; c < Math.floor(TW / clinic_frequency); c++) {
                    const w = c * clinic_frequency + (pos - 1);
                    if (w < TW) {
                        schedule[rid][w] = 'Clinic';
                    }
                }
            }

            const resWeeks = {};
            residents.forEach(r => {
                resWeeks[r.id] = {};
                Object.keys(TARGETS).forEach(rot => {
                    resWeeks[r.id][rot] = 0;
                });
            });

            // Helper functions
            function wouldExceed(rid, weeks, maxConsec) {
                const tempSched = { ...schedule[rid] };
                weeks.forEach(w => {
                    tempSched[w] = 'TEMP';
                });
                let maxRun = 0, currentRun = 0;
                for (let w = 0; w < TW; w++) {
                    const val = tempSched[w];
                    if (val !== null && val !== 'Clinic' && (IP_ROTS.has(val) || val === 'TEMP')) {
                        currentRun++;
                        maxRun = Math.max(maxRun, currentRun);
                    } else {
                        currentRun = 0;
                    }
                }
                return maxRun > maxConsec;
            }

            function balanceScore(rid, rot, extraWeeks) {
                const current = resWeeks[rid][rot];
                const ideal = (TARGETS[rot] * TW) / N || 0.5;
                const rotExcess = (current + extraWeeks) / Math.max(ideal, 0.5);
                const totalIp = Object.keys(TARGETS).reduce((sum, r) => sum + resWeeks[rid][r], 0);
                const idealMeanIP = (Object.values(TARGETS).reduce((a, b) => a + b) * TW / N) / 2.0;
                return rotExcess + 0.3 * (totalIp / Math.max(idealMeanIP, 0.5));
            }

            // PASS 1: Wards with dynamic targets
            ['SLUH', 'VA'].forEach(rot => {
                for (let w = 0; w <= TW - ward_contiguity; w++) {
                    const target = rot === 'SLUH' ? internSluhTarget[w] : internVaTarget[w];

                    while (coverage[rot][w] < target) {
                        const candidates = [];

                        residents.forEach(r => {
                            let allFree = true;
                            for (let i = 0; i < ward_contiguity; i++) {
                                if (schedule[r.id][w + i] !== null) {
                                    allFree = false;
                                    break;
                                }
                            }

                            if (allFree && !wouldExceed(r.id, Array.from({length: ward_contiguity}, (_, i) => w + i), max_consec_ip)) {
                                const score = balanceScore(r.id, rot, ward_contiguity);
                                candidates.push({ rid: r.id, score, rand: rng() });
                            }
                        });

                        if (candidates.length === 0) break;

                        candidates.sort((a, b) => a.score - b.score || a.rand - b.rand);
                        const rid = candidates[0].rid;

                        for (let i = 0; i < ward_contiguity; i++) {
                            schedule[rid][w + i] = rot;
                            coverage[rot][w + i]++;
                        }
                        resWeeks[rid][rot] += ward_contiguity;
                    }
                }
            });

            // PASS 2: NF
            for (let w = 0; w <= TW - nf_contiguity; w++) {
                while (coverage['NF'][w] < NF) {
                    const candidates = [];

                    residents.forEach(r => {
                        let allFree = true;
                        for (let i = 0; i < nf_contiguity; i++) {
                            if (schedule[r.id][w + i] !== null) {
                                allFree = false;
                                break;
                            }
                        }

                        if (allFree && !wouldExceed(r.id, Array.from({length: nf_contiguity}, (_, i) => w + i), max_consec_ip)) {
                            const score = balanceScore(r.id, 'NF', nf_contiguity);
                            candidates.push({ rid: r.id, score, rand: rng() });
                        }
                    });

                    if (candidates.length === 0) break;

                    candidates.sort((a, b) => a.score - b.score || a.rand - b.rand);
                    const rid = candidates[0].rid;

                    for (let i = 0; i < nf_contiguity; i++) {
                        schedule[rid][w + i] = 'NF';
                        coverage['NF'][w + i]++;
                    }
                    resWeeks[rid]['NF'] += nf_contiguity;
                }
            }

            // PASS 3: Staggered
            Array.from(STAG_ROTS).forEach(rot => {
                const target = TARGETS[rot];

                for (let w = 0; w < TW; w++) {
                    while (coverage[rot][w] < target) {
                        const candidates = [];

                        residents.forEach(r => {
                            let valid = schedule[r.id][w] === null;

                            if (valid && w > 0 && STAG_ROTS.has(schedule[r.id][w - 1])) {
                                valid = false;
                            }
                            if (valid && w < TW - 1 && STAG_ROTS.has(schedule[r.id][w + 1])) {
                                valid = false;
                            }

                            if (valid && !wouldExceed(r.id, [w], max_consec_ip)) {
                                const score = balanceScore(r.id, rot, 1);
                                candidates.push({ rid: r.id, score, rand: rng() });
                            }
                        });

                        if (candidates.length === 0) break;

                        candidates.sort((a, b) => a.score - b.score || a.rand - b.rand);
                        const rid = candidates[0].rid;

                        schedule[rid][w] = rot;
                        coverage[rot][w]++;
                        resWeeks[rid][rot] += 1;
                    }
                }
            });

            // PASS 4: Fill OP
            residents.forEach(r => {
                for (let w = 0; w < TW; w++) {
                    if (schedule[r.id][w] === null) {
                        schedule[r.id][w] = 'OP';
                    }
                }
            });

            // PASS 5: Jeopardy
            const jeopardyCount = {};
            residents.forEach(r => {
                jeopardyCount[r.id] = 0;
            });

            const jeopPerWeek = {};
            for (let w = 0; w < TW; w++) jeopPerWeek[w] = 0;

            const opPool = [];
            residents.forEach(r => {
                for (let w = 0; w < TW; w++) {
                    if (schedule[r.id][w] === 'OP') {
                        opPool.push({ rid: r.id, w });
                    }
                }
            });

            for (let i = opPool.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [opPool[i], opPool[j]] = [opPool[j], opPool[i]];
            }

            opPool.forEach(item => {
                if (jeopardyCount[item.rid] < jeopardy_cap && (jeopPerWeek[item.w] || 0) < 1) {
                    schedule[item.rid][item.w] = 'Jeopardy';
                    jeopardyCount[item.rid]++;
                    jeopPerWeek[item.w]++;
                }
            });

            return { schedule, residents, coverage, rotatorSchedule, rotatorSluhPerWeek, rotatorVaPerWeek };
        }

        // ============================================================================
        // UI INITIALIZATION
        // ============================================================================

        function initUI() {
            renderRosterSection();
            renderTargetsSection();
            updateKPIs();
            generateSchedule();
        }

        function renderRosterSection() {
            const container = document.getElementById('roster-container');
            container.innerHTML = '';

            if (currentLevel === 'senior') {
                container.innerHTML = `
                    <div class="param-group">
                        <label class="param-label">PGY-3 Count</label>
                        <input type="number" class="param-input" id="n-pgy3" value="${SENIOR_DEFAULTS.N_PGY3}" min="0">
                    </div>
                    <div class="param-group">
                        <label class="param-label">PGY-2 Count</label>
                        <input type="number" class="param-input" id="n-pgy2" value="${SENIOR_DEFAULTS.N_PGY2}" min="0">
                    </div>
                `;
            } else {
                container.innerHTML = `
                    <div class="param-group">
                        <label class="param-label">Categorical Count</label>
                        <input type="number" class="param-input" id="n-cat" value="${INTERN_DEFAULTS.N_CAT}" min="0">
                    </div>
                    <div class="param-group">
                        <label class="param-label">Preliminary Count</label>
                        <input type="number" class="param-input" id="n-prelim" value="${INTERN_DEFAULTS.N_PRELIM}" min="0">
                    </div>
                `;
            }
        }

        function renderRotatorsSection() {
            const container = document.getElementById('rotators-container');
            container.innerHTML = '';

            const rotators = ['Neuro', 'Anes', 'Psych', 'EM'];
            rotators.forEach(rot => {
                const value = INTERN_DEFAULTS[rot];
                container.innerHTML += `
                    <div class="param-group">
                        <label class="param-label">${rot}</label>
                        <input type="number" class="param-input" id="n-${rot.toLowerCase()}" value="${value}" min="0">
                    </div>
                `;
            });
        }

        function renderTargetsSection() {
            const container = document.getElementById('targets-container');
            container.innerHTML = '';

            let targets = [];
            if (currentLevel === 'senior') {
                targets = ['SLUH', 'VA', 'ID', 'NF', 'MICU', 'Bronze', 'Cards', 'Diamond', 'Gold'];
            } else {
                targets = ['SLUH', 'VA', 'NF', 'MICU', 'Cards'];
            }

            targets.forEach(rot => {
                const defaults = currentLevel === 'senior' ? SENIOR_DEFAULTS : INTERN_DEFAULTS;
                const value = defaults[rot];
                container.innerHTML += `
                    <div class="param-group">
                        <label class="param-label">${rot}</label>
                        <input type="number" class="param-input" id="target-${rot}" value="${value}" min="0">
                    </div>
                `;
            });
        }

        function updateKPIs() {
            if (!schedule || !coverage) return;

            const params = getParams();
            const residents = Object.keys(schedule).length;
            document.getElementById('kpi-residents').textContent = residents;

            const TW = 48;

            // Fully staffed calculation
            let fullyStaffed = 0;

            if (currentLevel === 'senior') {
                for (let w = 0; w < TW; w++) {
                    let meetsAll = true;

                    const requiredRots = ['SLUH', 'VA', 'ID', 'NF', 'MICU', 'Bronze', 'Cards', 'Diamond', 'Gold'];
                    requiredRots.forEach(rot => {
                        const target = params[rot];
                        if (target > 0 && coverage[rot] && coverage[rot][w] < target) {
                            meetsAll = false;
                        }
                    });

                    // Check for at least 1 jeopardy
                    let jeopCount = 0;
                    Object.keys(schedule).forEach(rid => {
                        if (schedule[rid][w] === 'Jeopardy') jeopCount++;
                    });
                    if (jeopCount < 1) meetsAll = false;

                    if (meetsAll) fullyStaffed++;
                }
            } else {
                // Intern: check intern+rotator counts
                for (let w = 0; w < TW; w++) {
                    let meetsAll = true;

                    // SLUH target (intern + rotator)
                    const sluhTotal = (coverage.SLUH ? coverage.SLUH[w] : 0) + (rotatorCoverage ? (rotatorCoverage.SLUH ? rotatorCoverage.SLUH[w] : 0) : 0);
                    if (sluhTotal < params.SLUH) meetsAll = false;

                    // VA target (intern + rotator)
                    const vaTotal = (coverage.VA ? coverage.VA[w] : 0) + (rotatorCoverage ? (rotatorCoverage.VA ? rotatorCoverage.VA[w] : 0) : 0);
                    if (vaTotal < params.VA) meetsAll = false;

                    // NF, MICU, Cards
                    if (coverage.NF[w] < params.NF) meetsAll = false;
                    if (coverage.MICU[w] < params.MICU) meetsAll = false;
                    if (coverage.Cards[w] < params.Cards) meetsAll = false;

                    // Jeopardy
                    let jeopCount = 0;
                    Object.keys(schedule).forEach(rid => {
                        if (schedule[rid][w] === 'Jeopardy') jeopCount++;
                    });
                    if (jeopCount < 1) meetsAll = false;

                    if (meetsAll) fullyStaffed++;
                }
            }

            document.getElementById('kpi-staffed').textContent = fullyStaffed;

            // Max consecutive IP
            let maxConsec = 0;
            const IP_ROTS = currentLevel === 'senior'
                ? new Set(['SLUH', 'VA', 'ID', 'NF', 'MICU', 'Bronze', 'Cards', 'Diamond', 'Gold'])
                : new Set(['SLUH', 'VA', 'NF', 'MICU', 'Cards']);

            Object.keys(schedule).forEach(rid => {
                let current = 0;
                for (let w = 0; w < TW; w++) {
                    const rot = schedule[rid][w];
                    if (IP_ROTS.has(rot)) {
                        current++;
                        maxConsec = Math.max(maxConsec, current);
                    } else {
                        current = 0;
                    }
                }
            });

            document.getElementById('kpi-maxconsec').textContent = maxConsec;

            // Violations: count residents with maxConsec > max_consec_ip
            const max_consec_ip = params.max_consec_ip;
            let violations = 0;
            Object.keys(schedule).forEach(rid => {
                let current = 0;
                let exceeded = false;
                for (let w = 0; w < TW; w++) {
                    const rot = schedule[rid][w];
                    if (IP_ROTS.has(rot)) {
                        current++;
                        if (current > max_consec_ip) exceeded = true;
                    } else {
                        current = 0;
                    }
                }
                if (exceeded) violations++;
            });

            document.getElementById('kpi-violations').textContent = violations;
        }

        function toggleSection(header) {
            const section = header.closest('.section');
            section.classList.toggle('collapsed');
            header.querySelector('.section-toggle').textContent = section.classList.contains('collapsed') ? '▶' : '▼';
        }

        function switchTab(index) {
            document.querySelectorAll('.tab').forEach((t, i) => {
                t.classList.toggle('active', i === index);
            });
            document.querySelectorAll('.tab-content').forEach((c, i) => {
                c.classList.toggle('active', i === index);
            });

            if (index === 1) renderCoverageTab();
            else if (index === 2) renderBalanceTab();
            else if (index === 3) renderCompareTab();
        }

        // ============================================================================
        // GENERATE SCHEDULE
        // ============================================================================

        function getParams() {
            const params = {
                TW: 48,
                CYCLE: 6,
                ward_contiguity: parseInt(document.getElementById('ward-contiguity').value) || 3,
                nf_contiguity: parseInt(document.getElementById('nf-contiguity').value) || 2,
                max_consec_ip: parseInt(document.getElementById('max-consec-ip').value) || 3,
                jeopardy_cap: parseInt(document.getElementById('jeopardy-cap').value) || 4,
                clinic_frequency: parseInt(document.getElementById('clinic-frequency').value) || 6,
                seed: parseInt(document.getElementById('seed').value) || 42
            };

            if (currentLevel === 'senior') {
                params.N_PGY3 = parseInt(document.getElementById('n-pgy3').value) || SENIOR_DEFAULTS.N_PGY3;
                params.N_PGY2 = parseInt(document.getElementById('n-pgy2').value) || SENIOR_DEFAULTS.N_PGY2;
                ['SLUH', 'VA', 'ID', 'NF', 'MICU', 'Bronze', 'Cards', 'Diamond', 'Gold'].forEach(rot => {
                    params[rot] = parseInt(document.getElementById(`target-${rot}`).value) || SENIOR_DEFAULTS[rot];
                });
            } else {
                params.N_CAT = parseInt(document.getElementById('n-cat').value) || INTERN_DEFAULTS.N_CAT;
                params.N_PRELIM = parseInt(document.getElementById('n-prelim').value) || INTERN_DEFAULTS.N_PRELIM;
                params.Neuro = parseInt(document.getElementById('n-neuro').value) || INTERN_DEFAULTS.Neuro;
                params.Anes = parseInt(document.getElementById('n-anes').value) || INTERN_DEFAULTS.Anes;
                params.Psych = parseInt(document.getElementById('n-psych').value) || INTERN_DEFAULTS.Psych;
                params.EM = parseInt(document.getElementById('n-em').value) || INTERN_DEFAULTS.EM;
                ['SLUH', 'VA', 'NF', 'MICU', 'Cards'].forEach(rot => {
                    params[rot] = parseInt(document.getElementById(`target-${rot}`).value) || INTERN_DEFAULTS[rot];
                });
            }

            return params;
        }

        function generateSchedule() {
            document.getElementById('loading').classList.add('active');

            setTimeout(() => {
                const params = getParams();

                if (currentLevel === 'senior') {
                    const result = scheduleSenior(params);
                    schedule = result.schedule;
                    coverage = result.coverage;
                    rotatorCoverage = null;
                } else {
                    const result = scheduleIntern(params);
                    schedule = result.schedule;
                    coverage = result.coverage;
                    rotatorSchedule = result.rotatorSchedule;
                    rotatorCoverage = {
                        SLUH: Object.values(result.rotatorSluhPerWeek),
                        VA: Object.values(result.rotatorVaPerWeek)
                    };
                }

                updateKPIs();
                renderScheduleGrid();
                document.getElementById('loading').classList.remove('active');
            }, 100);
        }

        function findBestSeed() {
            document.getElementById('loading').classList.add('active');
            const originalSeed = document.getElementById('seed').value;

            setTimeout(() => {
                let bestSeed = 0;
                let bestStaffed = 0;
                const params = getParams();

                for (let s = 0; s <= 99; s++) {
                    params.seed = s;

                    let result;
                    if (currentLevel === 'senior') {
                        result = scheduleSenior(params);
                    } else {
                        result = scheduleIntern(params);
                    }

                    schedule = result.schedule;
                    coverage = result.coverage;
                    if (currentLevel === 'intern') {
                        rotatorSchedule = result.rotatorSchedule;
                    }

                    const TW = 48;
                    let fullyStaffed = 0;

                    if (currentLevel === 'senior') {
                        for (let w = 0; w < TW; w++) {
                            let meetsAll = true;
                            const requiredRots = ['SLUH', 'VA', 'NF', 'MICU'];
                            requiredRots.forEach(rot => {
                                if (coverage[rot][w] < params[rot]) meetsAll = false;
                            });
                            let jeopCount = 0;
                            Object.keys(schedule).forEach(rid => {
                                if (schedule[rid][w] === 'Jeopardy') jeopCount++;
                            });
                            if (jeopCount < 1) meetsAll = false;
                            if (meetsAll) fullyStaffed++;
                        }
                    } else {
                        const rSluh = result.rotatorSluhPerWeek;
                        const rVa = result.rotatorVaPerWeek;
                        for (let w = 0; w < TW; w++) {
                            let meetsAll = true;
                            if ((coverage.SLUH[w] || 0) + (rSluh[w] || 0) < params.SLUH) meetsAll = false;
                            if ((coverage.VA[w] || 0) + (rVa[w] || 0) < params.VA) meetsAll = false;
                            if (coverage.NF[w] < params.NF) meetsAll = false;
                            if (coverage.MICU[w] < params.MICU) meetsAll = false;
                            if (coverage.Cards[w] < params.Cards) meetsAll = false;
                            let jeopCount = 0;
                            Object.keys(schedule).forEach(rid => {
                                if (schedule[rid][w] === 'Jeopardy') jeopCount++;
                            });
                            if (jeopCount < 1) meetsAll = false;
                            if (meetsAll) fullyStaffed++;
                        }
                    }

                    if (fullyStaffed > bestStaffed) {
                        bestStaffed = fullyStaffed;
                        bestSeed = s;
                    }
                }

                document.getElementById('seed').value = bestSeed;
                generateSchedule();
            }, 100);
        }

        function renderScheduleGrid() {
            const container = document.getElementById('schedule-grid');
            container.innerHTML = '';

            const params = getParams();
            const N = currentLevel === 'senior' ? params.N_PGY3 + params.N_PGY2 : params.N_CAT + params.N_PRELIM;
            const TW = 48;

            let html = '<tr><th>Resident</th>';
            for (let w = 1; w <= TW; w++) {
                html += `<th>W${w}</th>`;
            }
            html += '<th>IP</th><th>OP</th><th>CL</th><th>MAX</th>';

            let targets = [];
            if (currentLevel === 'senior') {
                targets = ['SLUH', 'VA', 'ID', 'NF', 'MICU', 'Bronze', 'Cards', 'Diamond', 'Gold'];
            } else {
                targets = ['SLUH', 'VA', 'NF', 'MICU', 'Cards'];
            }
            targets.forEach(rot => {
                html += `<th>${ABBREV[rot]}</th>`;
            });
            html += '</tr>';

            renderLegend();

            const IP_ROTS = currentLevel === 'senior'
                ? new Set(['SLUH', 'VA', 'ID', 'NF', 'MICU', 'Bronze', 'Cards', 'Diamond', 'Gold'])
                : new Set(['SLUH', 'VA', 'NF', 'MICU', 'Cards']);

            for (let rid = 0; rid < N; rid++) {
                const name = currentLevel === 'senior'
                    ? (rid < params.N_PGY3 ? `PGY3-${rid+1}` : `PGY2-${rid-params.N_PGY3+1}`)
                    : (rid < params.N_CAT ? `CAT-${rid+1}` : `PRELIM-${rid-params.N_CAT+1}`);

                html += `<tr><td class="resident-name">${name}</td>`;

                for (let w = 0; w < TW; w++) {
                    const rot = schedule[rid][w];
                    const color = COLORS[rot] || '#fff';
                    const text = ABBREV[rot] || rot;
                    html += `<td class="schedule-cell" style="background-color: ${color};">${text}</td>`;
                }

                let ipCount = 0, opCount = 0, clCount = 0, maxConsec = 0, currentConsec = 0;
                for (let w = 0; w < TW; w++) {
                    const rot = schedule[rid][w];
                    if (rot === 'OP') opCount++;
                    else if (rot === 'Clinic') clCount++;
                    else if (IP_ROTS.has(rot)) {
                        ipCount++;
                        currentConsec++;
                        maxConsec = Math.max(maxConsec, currentConsec);
                    } else {
                        currentConsec = 0;
                    }
                }

                html += `<td>${ipCount}</td><td>${opCount}</td><td>${clCount}</td><td>${maxConsec}</td>`;

                targets.forEach(rot => {
                    let count = 0;
                    for (let w = 0; w < TW; w++) {
                        if (schedule[rid][w] === rot) count++;
                    }
                    html += `<td>${count}</td>`;
                });

                html += '</tr>';
            }

            // Rotator rows for intern
            if (currentLevel === 'intern' && rotatorSchedule) {
                const rotatorTypes = ['Neuro', 'Anes', 'Psych', 'EM'];
                const rotatorLabels = {
                    'Neuro': 'NEUROLOGY ROTATORS',
                    'Anes': 'ANESTHESIA ROTATORS',
                    'Psych': 'PSYCHIATRY ROTATORS',
                    'EM': 'EMERGENCY MED ROTATORS'
                };
                rotatorTypes.forEach(type => {
                    const rids = Object.keys(rotatorSchedule).filter(rid => rid.startsWith(type));
                    if (rids.length === 0) return;
                    // Section header
                    html += `<tr class="section-header"><td colspan="${TW + 5 + targets.length}" style="background:#D6DCE4;font-weight:700;padding:5px 8px;text-align:left;">${rotatorLabels[type]} (${rids.length})</td></tr>`;
                    rids.forEach(rid => {
                        html += `<tr><td class="resident-name">${rid}</td>`;
                        for (let w = 0; w < TW; w++) {
                            const rot = rotatorSchedule[rid][w];
                            if (rot) {
                                const color = COLORS[rot] || '#fff';
                                const text = ABBREV[rot] || rot;
                                html += `<td class="schedule-cell" style="background-color: ${color};">${text}</td>`;
                            } else {
                                html += `<td class="schedule-cell" style="background:#f0f0f0;"></td>`;
                            }
                        }
                        // Empty summary cells for rotators
                        html += `<td></td><td></td><td></td><td></td>`;
                        targets.forEach(() => html += `<td></td>`);
                        html += '</tr>';
                    });
                });
            }

            // Coverage summary row
            html += `<tr class="coverage-row"><td colspan="${TW + 5 + targets.length}" style="background:#FFF2CC;font-weight:700;padding:5px 8px;text-align:left;">WEEKLY COVERAGE SUMMARY</td></tr>`;
            let coverageRots = currentLevel === 'senior'
                ? ['SLUH', 'VA', 'ID', 'NF', 'MICU', 'Bronze', 'Cards', 'Diamond', 'Gold', 'Jeopardy']
                : ['SLUH', 'VA', 'NF', 'MICU', 'Cards', 'Jeopardy'];
            coverageRots.forEach(rot => {
                const target = params[rot] || 1;
                html += `<tr><td class="resident-name" style="font-weight:600;">${rot}</td>`;
                for (let w = 0; w < TW; w++) {
                    let count = coverage[rot] ? coverage[rot][w] : 0;
                    // For intern SLUH/VA, add rotator coverage
                    if (currentLevel === 'intern' && rotatorCoverage && (rot === 'SLUH' || rot === 'VA')) {
                        count += rotatorCoverage[rot] ? rotatorCoverage[rot][w] : 0;
                    }
                    const ok = count >= target;
                    html += `<td class="schedule-cell" style="background:${ok ? '#B3FFB3' : '#FF9999'};font-weight:600;">${count}</td>`;
                }
                html += `<td colspan="${4 + targets.length}"></td></tr>`;
            });

            container.innerHTML = html;
        }

        function renderLegend() {
            const legend = document.getElementById('color-legend');
            let html = '';

            let rotations = [];
            if (currentLevel === 'senior') {
                rotations = ['SLUH', 'VA', 'ID', 'NF', 'MICU', 'Bronze', 'Cards', 'Diamond', 'Gold', 'OP', 'Clinic', 'Jeopardy'];
            } else {
                rotations = ['SLUH', 'VA', 'NF', 'MICU', 'Cards', 'ICU*', 'OP', 'Clinic', 'Jeopardy'];
            }

            rotations.forEach(rot => {
                const color = COLORS[rot] || '#fff';
                const text = ABBREV[rot] || rot;
                html += `
                    <div class="legend-item">
                        <div class="legend-swatch" style="background-color: ${color};"></div>
                        <span>${text} = ${rot}</span>
                    </div>
                `;
            });

            legend.innerHTML = html;
        }

        // ============================================================================
        // COVERAGE TAB
        // ============================================================================

        function renderCoverageTab() {
            const params = getParams();
            const TW = 48;

            let rotations = [];
            if (currentLevel === 'senior') {
                rotations = ['SLUH', 'VA', 'ID', 'NF', 'MICU', 'Bronze', 'Cards', 'Diamond', 'Gold'];
            } else {
                rotations = ['SLUH', 'VA', 'NF', 'MICU', 'Cards'];
            }

            const z = rotations.map(rot =>
                Array.from({length: TW}, (_, w) => coverage[rot][w])
            );

            const targets = rotations.map(rot => params[rot] || 0);
            const colorscale = [
                [0, '#ff6b6b'],
                [0.5, '#fff9c4'],
                [1, '#81c784']
            ];

            Plotly.newPlot('coverage-heatmap', [{
                z: z,
                x: Array.from({length: TW}, (_, i) => `W${i+1}`),
                y: rotations,
                type: 'heatmap',
                colorscale: colorscale,
                hovertemplate: '<b>%{y}</b><br>%{x}: %{z} residents<extra></extra>'
            }], {
                title: 'Rotation Coverage by Week (Green=Target Met, Red=Understaffed)',
                xaxis: { title: 'Week' },
                yaxis: { title: 'Rotation' },
                height: 300
            });

            const table = document.getElementById('coverage-table');
            let html = '<tr><th>Week</th>';
            rotations.forEach(rot => {
                html += `<th>${ABBREV[rot]} (T=${targets[rotations.indexOf(rot)]})</th>`;
            });
            html += '</tr>';

            for (let w = 0; w < TW; w++) {
                html += `<tr><td><b>W${w+1}</b></td>`;
                rotations.forEach(rot => {
                    const count = coverage[rot][w];
                    const target = targets[rotations.indexOf(rot)];
                    const color = count >= target ? '#c8e6c9' : '#ffcdd2';
                    html += `<td style="background-color: ${color};">${count}</td>`;
                });
                html += '</tr>';
            }

            table.innerHTML = html;
        }

        // ============================================================================
        // BALANCE TAB
        // ============================================================================

        function renderBalanceTab() {
            const params = getParams();
            const N = currentLevel === 'senior' ? params.N_PGY3 + params.N_PGY2 : params.N_CAT + params.N_PRELIM;
            const TW = 48;

            const IP_ROTS = currentLevel === 'senior'
                ? new Set(['SLUH', 'VA', 'ID', 'NF', 'MICU', 'Bronze', 'Cards', 'Diamond', 'Gold'])
                : new Set(['SLUH', 'VA', 'NF', 'MICU', 'Cards']);

            const ipWeeks = {};
            for (let rid = 0; rid < N; rid++) {
                let count = 0;
                for (let w = 0; w < TW; w++) {
                    const rot = schedule[rid][w];
                    if (IP_ROTS.has(rot)) {
                        count++;
                    }
                }
                ipWeeks[rid] = count;
            }

            const ipArray = Object.values(ipWeeks);
            const mean = ipArray.reduce((a, b) => a + b, 0) / ipArray.length;
            const std = Math.sqrt(ipArray.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / ipArray.length);

            Plotly.newPlot('balance-histogram', [{
                x: ipArray,
                type: 'histogram',
                nbinsx: 20,
                marker: { color: '#2a5298' }
            }], {
                title: `IP Weeks Distribution (Mean: ${mean.toFixed(1)}, SD: ${std.toFixed(2)})`,
                xaxis: { title: 'IP Weeks' },
                yaxis: { title: 'Residents' },
                height: 300
            });

            let rotations = [];
            if (currentLevel === 'senior') {
                rotations = ['SLUH', 'VA', 'ID', 'NF', 'MICU', 'Bronze', 'Cards', 'Diamond', 'Gold'];
            } else {
                rotations = ['SLUH', 'VA', 'NF', 'MICU', 'Cards'];
            }

            const traces = rotations.map(rot => {
                const counts = [];
                for (let rid = 0; rid < N; rid++) {
                    let count = 0;
                    for (let w = 0; w < TW; w++) {
                        if (schedule[rid][w] === rot) count++;
                    }
                    counts.push(count);
                }
                return {
                    y: counts,
                    name: rot,
                    type: 'box'
                };
            });

            Plotly.newPlot('rotation-boxplot', traces, {
                title: 'Weeks per Rotation Distribution',
                yaxis: { title: 'Weeks' },
                height: 300
            });

            const outliers = [];
            for (let rid = 0; rid < N; rid++) {
                if (Math.abs(ipWeeks[rid] - mean) > 1.5 * std) {
                    const name = currentLevel === 'senior'
                        ? (rid < params.N_PGY3 ? `PGY3-${rid+1}` : `PGY2-${rid-params.N_PGY3+1}`)
                        : (rid < params.N_CAT ? `CAT-${rid+1}` : `PRELIM-${rid-params.N_CAT+1}`);
                    outliers.push({ name, weeks: ipWeeks[rid], deviation: Math.abs(ipWeeks[rid] - mean).toFixed(2) });
                }
            }

            const table = document.getElementById('outliers-table');
            let html = '<tr><th>Resident</th><th>IP Weeks</th><th>Deviation (SD)</th></tr>';
            outliers.forEach(o => {
                const color = o.weeks > mean ? '#ffcdd2' : '#c8e6c9';
                html += `<tr style="background-color: ${color};"><td>${o.name}</td><td>${o.weeks}</td><td>${o.deviation}</td></tr>`;
            });
            if (outliers.length === 0) {
                html += '<tr><td colspan="3" style="text-align: center; color: #999;">No outliers</td></tr>';
            }
            table.innerHTML = html;
        }

        // ============================================================================
        // COMPARE TAB
        // ============================================================================

        function saveBaseline() {
            const params = getParams();

            baseline = {};
            Object.keys(schedule).forEach(rid => {
                baseline[rid] = { ...schedule[rid] };
            });

            baselineCoverage = {};
            Object.keys(coverage).forEach(rot => {
                baselineCoverage[rot] = { ...coverage[rot] };
            });

            if (currentLevel === 'intern') {
                baselineRotatorSchedule = {};
                Object.keys(rotatorSchedule).forEach(rid => {
                    baselineRotatorSchedule[rid] = { ...rotatorSchedule[rid] };
                });
            }

            document.getElementById('compare-tab').style.display = 'block';
            alert('Baseline saved! Switch Generate to compare.');
        }

        function renderCompareTab() {
            if (!baseline) {
                document.getElementById('compare-content').innerHTML = '<p>No baseline saved. Click "Save as Baseline" first.</p>';
                return;
            }

            const params = getParams();
            const N = currentLevel === 'senior' ? params.N_PGY3 + params.N_PGY2 : params.N_CAT + params.N_PRELIM;
            const TW = 48;

            let html = '<h3>KPI Comparison</h3><div class="kpi-comparison">';

            const baselineResidents = Object.keys(baseline).length;
            const currentResidents = N;
            const residentsDelta = currentResidents - baselineResidents;
            const residentsIndicator = residentsDelta === 0 ? '=' : (residentsDelta > 0 ? '↑' : '↓');
            const residentsColor = residentsDelta === 0 ? 'same' : (residentsDelta > 0 ? 'improved' : 'degraded');

            html += `
                <div class="kpi-card">
                    <div class="kpi-card-label">Residents</div>
                    <div class="kpi-card-values">
                        <div class="kpi-baseline">
                            <div class="kpi-baseline-label">Baseline</div>
                            <div class="kpi-baseline-value">${baselineResidents}</div>
                        </div>
                        <div class="kpi-current">
                            <div class="kpi-current-label">Current</div>
                            <div class="kpi-current-value">${currentResidents}</div>
                        </div>
                        <div class="kpi-delta ${residentsColor}">${residentsIndicator}</div>
                    </div>
                </div>
            `;

            let baselineMaxConsec = 0, currentMaxConsec = 0;
            const IP_ROTS = currentLevel === 'senior'
                ? new Set(['SLUH', 'VA', 'ID', 'NF', 'MICU', 'Bronze', 'Cards', 'Diamond', 'Gold'])
                : new Set(['SLUH', 'VA', 'NF', 'MICU', 'Cards']);

            for (let rid = 0; rid < Math.max(baselineResidents, N); rid++) {
                let current = 0;
                if (rid < baselineResidents) {
                    for (let w = 0; w < TW; w++) {
                        const rot = baseline[rid][w];
                        if (IP_ROTS.has(rot)) {
                            current++;
                            baselineMaxConsec = Math.max(baselineMaxConsec, current);
                        } else {
                            current = 0;
                        }
                    }
                }

                current = 0;
                if (rid < N) {
                    for (let w = 0; w < TW; w++) {
                        const rot = schedule[rid][w];
                        if (IP_ROTS.has(rot)) {
                            current++;
                            currentMaxConsec = Math.max(currentMaxConsec, current);
                        } else {
                            current = 0;
                        }
                    }
                }
            }

            const maxConsecDelta = currentMaxConsec - baselineMaxConsec;
            const maxConsecIndicator = maxConsecDelta === 0 ? '=' : (maxConsecDelta < 0 ? '↑' : '↓');
            const maxConsecColor = maxConsecDelta === 0 ? 'same' : (maxConsecDelta < 0 ? 'improved' : 'degraded');

            html += `
                <div class="kpi-card">
                    <div class="kpi-card-label">Max Consecutive IP</div>
                    <div class="kpi-card-values">
                        <div class="kpi-baseline">
                            <div class="kpi-baseline-label">Baseline</div>
                            <div class="kpi-baseline-value">${baselineMaxConsec}</div>
                        </div>
                        <div class="kpi-current">
                            <div class="kpi-current-label">Current</div>
                            <div class="kpi-current-value">${currentMaxConsec}</div>
                        </div>
                        <div class="kpi-delta ${maxConsecColor}">${maxConsecIndicator}</div>
                    </div>
                </div>
            `;

            let rotations = [];
            if (currentLevel === 'senior') {
                rotations = ['SLUH', 'VA', 'ID', 'NF', 'MICU', 'Bronze', 'Cards', 'Diamond', 'Gold'];
            } else {
                rotations = ['SLUH', 'VA', 'NF', 'MICU', 'Cards'];
            }

            rotations.forEach(rot => {
                const baslineCount = baselineCoverage[rot][0] * TW; // placeholder, should sum
                let baselineCount = 0, currentCount = 0;

                for (let w = 0; w < TW; w++) {
                    baselineCount += baselineCoverage[rot][w];
                    currentCount += coverage[rot][w];
                }

                const delta = currentCount - baselineCount;
                const indicator = delta === 0 ? '=' : (delta > 0 ? '↑' : '↓');
                const color = delta === 0 ? 'same' : 'degraded';

                html += `
                    <div class="kpi-card">
                        <div class="kpi-card-label">${rot} Weeks</div>
                        <div class="kpi-card-values">
                            <div class="kpi-baseline">
                                <div class="kpi-baseline-label">Baseline</div>
                                <div class="kpi-baseline-value">${baselineCount}</div>
                            </div>
                            <div class="kpi-current">
                                <div class="kpi-current-label">Current</div>
                                <div class="kpi-current-value">${currentCount}</div>
                            </div>
                            <div class="kpi-delta ${color}">${indicator}</div>
                        </div>
                    </div>
                `;
            });

            html += '</div>';

            document.getElementById('compare-content').innerHTML = html;
        }

        function resetDefaults() {
            if (currentLevel === 'senior') {
                Object.keys(SENIOR_DEFAULTS).forEach(key => {
                    const el = document.getElementById(
                        key === 'N_PGY3' ? 'n-pgy3' :
                        key === 'N_PGY2' ? 'n-pgy2' :
                        key === 'TW' ? null :
                        key === 'CYCLE' ? null :
                        `target-${key}` || null
                    );
                    if (el) el.value = SENIOR_DEFAULTS[key];
                });
                document.getElementById('seed').value = 42;
            } else {
                Object.keys(INTERN_DEFAULTS).forEach(key => {
                    const el = document.getElementById(
                        key === 'N_CAT' ? 'n-cat' :
                        key === 'N_PRELIM' ? 'n-prelim' :
                        key === 'Neuro' ? 'n-neuro' :
                        key === 'Anes' ? 'n-anes' :
                        key === 'Psych' ? 'n-psych' :
                        key === 'EM' ? 'n-em' :
                        key === 'TW' ? null :
                        `target-${key}` || null
                    );
                    if (el) el.value = INTERN_DEFAULTS[key];
                });
                document.getElementById('seed').value = 6;
            }
            generateSchedule();
        }

        // ============================================================================
        // LEVEL SWITCHING
        // ============================================================================

        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    currentLevel = e.target.dataset.level;
                    document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');

                    document.getElementById('rotators-section').style.display = currentLevel === 'intern' ? 'block' : 'none';

                    renderRosterSection();
                    renderRotatorsSection();
                    renderTargetsSection();

                    const cap = currentLevel === 'senior' ? 4 : 3;
                    document.getElementById('jeopardy-cap').value = cap;

                    document.getElementById('seed').value = currentLevel === 'senior' ? 42 : 6;

                    generateSchedule();
                });
            });

            renderRosterSection();
            renderRotatorsSection();
            renderTargetsSection();
            initUI();
        });
    </script>
</body>
</html>
